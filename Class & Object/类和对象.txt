基于函数(算法)编程

面向对象编程：
1、访问对属性关闭，对方法开放
2、指针成员在构造函数中申请，在析构函数中释放 //内存泄漏
3、类中有指针成员，要写拷贝构造和赋值运算符重载的深度拷贝 //安全
4、类对扩展开放，对修改关闭

class 类关键字

struct 和 class ?
默认的访问权限不一样
struct : 默认公有
class : 默认私有

private : 私有权限:只能在类内访问
public : 公有权限:类内和类外都可以访问

编译器默认生成的函数
1、无参构造
2、拷贝构造
3、赋值运算符的重载函数


构造函数和析构函数

构造函数：用于初始化对象状态的函数
特点：
1、不需要手动调用
2、当不定义构造函数时，编译器会自动创建一个默认的构造函数Student(){}
3、函数形式：函数名和类名相同，无返回值
4、当自定义了构造函数，编译器不会再帮该类生成默认的构造函数
5、构造函数可以重载

拷贝构造函数
1、函数形式：函数名和类名相同，无返回值，参数必须是对象的引用（否则将无限拷贝内存）
2、浅拷贝：当类中含有指针属性时，如果调用拷贝构造，拷贝的是指针的值（地址），
   使得两个对象的指针指向同一块内存，析构中释放时发生二次释放
   
   深度拷贝：内存复制



析构函数：用来释放对象的状态
1、不需要手动调用
2、函数形式：函数名和类名相同，名称前加一个~
3、析构函数没有参数
4、析构函数不能重载



RVO优化：return value optimizer : 返回值优化       减少拷贝
左值-拷贝    右值-不用拷贝-RVO优化

将亡值：右值

new&delete 和 malloc&free
1、malloc free 是函数，new delete 是关键字
2、new 不需要计算内存大小，不需要转换指针，不需要判断指针是否为空
3、new delete 会调用构造和析构函数，malloc free 不会


explicit:防止隐式转换

const
初始化列表
1、常成员变量必须在初始化列表中进行初始化
2、普通成员变量也可以在初始化列表中初始化
3、初始化列表的操作快于构造函数的主体

static
C语言：1、局部变量：延长生命周期，只初始化一次
      2、全局变量：只在当前文件可见  extern 
C++：1、修饰成员变量：该变量不属于某一个类的成员，而属于类，由该类的所有成员共享
注意事项：1、初始化不由类的对象完成，而由类自己完成
     2、修饰成员函数：该函数不属于成员，而由所有成员共享
       静态成员函数不能访问普通类的成员变量，只能访问静态成员变量


单例：全局该类只有一个对象的设计模式
1、防止对象在外部创建：构造函数私有化
2、构建一个静态接口，给外部使用
3、在静态接口中构建static变量，返回该变量的指针

this指针：指向本类对象
1、*this获取本对象
2、用于区分类成员和形参
3、静态函数不能使用this指针

friend 友元关键字
友元函数:访问类的私有成员
友元类：该类可以访问类的所有私有成员
友元关系不能进行传递,是单向的

const对成员函数的修饰：
1、const  int* func()  //保护返回值
2、void func2(const int &a)  //保护引用形参
3、void func3()const  //该函数内不允许对成员变量做修改  保护成员变量